<!DOCTYPE HTML>
<html>

<head>
  <meta charset="UTF-8">
  <title>GPXmagic</title>
  <meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no">
  <script type="text/javascript" src="main.js"></script>
  <script src='https://api.mapbox.com/mapbox-gl-js/v2.4.1/mapbox-gl.js'></script>
  <link href='https://api.mapbox.com/mapbox-gl-js/v2.4.1/mapbox-gl.css' rel='stylesheet' />
  <script src="https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-draw/v1.2.2/mapbox-gl-draw.js"></script>
  <link rel="stylesheet" href="https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-draw/v1.2.2/mapbox-gl-draw.css" type="text/css">
</head>

<body>
<div id="myapp"></div>
</body>

<script type="text/javascript">

const app = Elm.Main.init({
    node: document.getElementById("myapp"),
    flags: rememberedBytes()
});

// OAuth integration ...
/* Fetch back generated bytes from the local storage */
function rememberedBytes() {
    const bytes = localStorage.getItem("bytes");
    return bytes ? bytes.split(",").map(x => parseInt(x,10)) : null;
}

/* Generate high entropy random bytes using the Web Crypto API and
remember them so that they are preserved between redirections. This
allows to protect for XSS & authorization code attacks */
app.ports.genRandomBytes.subscribe(n => {
    const buffer = new Uint8Array(n);
    crypto.getRandomValues(buffer);
    const bytes = Array.from(buffer);
    localStorage.setItem("bytes", bytes);
    app.ports.randomBytes.send(bytes);
});

// Was Mapbox integration, now more a general port for commands from Elm.
app.ports.commandPort.subscribe(incomingMessageHandler);

// We use port messages to synchronise our state here with Elm.
var map;
var isMapCreated = false;
var trackAdded = false;
var dragPointStart;
var dragging = false;
var clickToDrag = false;
var pointsLayerAdded = false;
var sketchMap;

var canvas;
// Make dummy feature just for making drag point feedback.
var drag = {
    'type': 'FeatureCollection',
    'features': [
        {
            'type': 'Feature',
            'geometry': {
                'type': 'Point',
                'coordinates': [0, 0]
            }
        }
    ]
};

function startDraggingPoint(e) {
//    console.log(e);
    canvas.style.cursor = 'grab';

    var coords = e.lngLat;
    drag.features[0].geometry.coordinates = [coords.lng, coords.lat];

    if (dragging) {
        map.removeLayer('drag');
        map.removeSource('drag');
    };

    map.addSource('drag', {
        'type': 'geojson',
        'data': drag
        });

 //   console.log('adding drag layer');
    map.addLayer({
        'id': 'drag',
        'type': 'circle',
        'source': 'drag',
        'paint': {
            'circle-radius': 5,
            'circle-color': '#ffff00'
        }
    });

    dragging = true;
    dragPointStart = e.lngLat;
    map.on('mousemove', onMove);
    map.once('mouseup', onUp);
};

// Copied from mapbox point dragging example
function onMove(e) {
    var coords = e.lngLat;

    //console.log(e);

    // Set a UI indicator for dragging.
    canvas.style.cursor = 'grabbing';

    // Note we don't tell Elm until the point is dropped.
    // Update the Point feature in `geojson` coordinates
    // and call setData to the source layer `point` on it.
    drag.features[0].geometry.coordinates = [coords.lng, coords.lat];
    map.getSource('drag').setData(drag);

};

function onUp(e) {
    //console.log(e);
    var coords = e.lngLat;

    canvas.style.cursor = '';
    if (dragging) {
        map.removeLayer('drag');
        map.removeSource('drag');
        dragging = false;
    };

    map.off('mousemove', onMove);
    map.off('touchmove', onMove);

    app.ports.messageReceiver.send
        ( { 'msg' : 'drag'
          , 'start' : dragPointStart
          , 'end' : coords
      } );
};

function incomingMessageHandler(msg) {
//    console.log('behold, a message from the land of Elm');
//    console.log(msg);

    switch (msg.Cmd) {
        case 'Init':
            if (!isMapCreated) {
                makeTheMap(msg);
            }
            break;

        case 'Repaint':
            if (isMapCreated) {
                map.resize();
                sketchMap.resize();
            }
            break;

        case 'Track':
            if (isMapCreated) {
                addLineToMap(msg.data, msg.points);
                setClickMode('true', msg.points);
            }
            break;

        case 'Mark':
            if (isMapCreated) {
                //console.log('adding marker');
                addOptionals(msg);
            }
            break;

        case 'Drag':
            if (isMapCreated) {
                setClickMode(msg.Enable, msg.points);
            }
            break;

        case 'Centre':
            if (isMapCreated) {
                centreMap(msg.lon, msg.lat);
            }
            break;

        case 'Zoom':
            if (isMapCreated) {
                map.setZoom(msg.zoom)
            }
            break;

        case 'Elev':
            if (isMapCreated) {
                const source = map.getSource('route');
                const elevations =
                    source._data.geometry.coordinates.map(
                        v => map.queryTerrainElevation(v)
                    );
                //console.log(elevations);

                app.ports.messageReceiver.send(
                  { 'msg' : 'elevations'
                  , 'elevations' : elevations
                  }
                );
            }
            break;

        case 'Sketch':
            sketchMapEnable(msg.lon, msg.lat, msg.zoom);
            break;

        case 'ExitSketch':
            sketchDataCapture();
            break;

        case 'storage.set':
            //console.log(msg.key); console.log(msg.value);
            localStorage.setItem(msg.key, JSON.stringify( msg.value ) );
            break;

        case 'storage.get':
            var val = null;
            try {
              val = JSON.parse(localStorage.getItem(msg.key))
            } catch (e) {
            };
            app.ports.messageReceiver.send({ 'msg' : 'storage.got', 'key' : msg.key, 'value' : val });
            break;

        case 'storage.list':
            var keys = [];
            var cnt = localStorage.length;
            for (var i = 0; i < cnt; i++) {
                var key = localStorage.key(i);
                keys.push(key);
            };
            //console.log(keys);
            app.ports.messageReceiver.send({ 'msg' : 'storage.keys', 'keys' : keys });
            break;

        case 'storage.clear':
            localStorage.clear();
            break;
    }
};

function makeTheMap(msg) {
    //console.log('create the map');

    mapboxgl.accessToken = msg.token;
    var element = document.getElementById("map");
    if(typeof(element) != 'undefined' && element != null && !isMapCreated)
    {
        //console.log('making the map now');

        map = new mapboxgl.Map({
            container: 'map',
            style: 'mapbox://styles/mapbox/streets-v11',
            center: [msg.lon, msg.lat],
            zoom: msg.zoom
        });

        map.on('load', function () {
            //console.log('tell Elm the map is ready');
            isMapCreated = true;
            canvas  = map.getCanvasContainer();
            // Add zoom and rotation controls to the map.
            map.addControl(new mapboxgl.NavigationControl());

            // Add terrain source, with slight exaggeration
            map.addSource('mapbox-dem', {
              'type': 'raster-dem',
              'url': 'mapbox://mapbox.terrain-rgb',
              'tileSize': 512,
              'maxzoom': 14
            });
            map.setTerrain({ 'source': 'mapbox-dem'});

            // add a sky layer that will show when the map is highly pitched
            map.addLayer({
              'id': 'sky',
              'type': 'sky',
              'paint': {
              'sky-type': 'atmosphere',
              'sky-atmosphere-sun': [0.0, 0.0],
              'sky-atmosphere-sun-intensity': 15
              }
            });

            app.ports.messageReceiver.send({ 'msg' : 'map ready' });
        });

    } else {
        //No 'map' node, we have to keep checking.
        //console.log('no map node');
        app.ports.messageReceiver.send({ 'msg' : 'no node' });
    }

    createSketchMap(msg);
};

function centreMap(lon, lat) {
    map.setCenter([lon, lat]);
};

function addLineToMap(data, points) {
    //console.log('add line to map');

    if (trackAdded) {
        //console.log('removing existing track');
        map.removeLayer('route');
        map.removeSource('route');
        trackAdded = false;
    }

    //console.log('adding geojson data');
    map.addSource('route', {
        'type': 'geojson',
        'data': data
        });

    //console.log('adding route layer');
    map.addLayer({
        'id': 'route',
        'type': 'line',
        'source': 'route',
        'layout': {
        'line-join': 'round',
        'line-cap': 'round'
        },
        'paint': {
            'line-color': '#888',
            'line-width': 8
        }
    });

    trackAdded = true;
    setClickMode(clickToDrag, points);

    app.ports.messageReceiver.send(
      { 'msg' : 'track ready' }
    );
};

function setClickMode(newMode, points) {
    if (clickToDrag && pointsLayerAdded) {
        map.removeLayer('points');
        map.removeSource('points');
        pointsLayerAdded = false;
    }

    clickToDrag = newMode;
    if (clickToDrag && !pointsLayerAdded) {
        map.addSource('points', {
            'type': 'geojson',
            'data': points
            });

        map.addLayer({
            'id': 'points',
            'type': 'circle',
            'source': 'points',
            'paint': {
                'circle-radius': 5,
                'circle-color': '#ff8f00'
            }
        });

        pointsLayerAdded = true;

        // When the cursor enters a feature in the point layer, prepare for dragging.
        map.on('mouseenter', 'points', function () {
            canvas.style.cursor = 'move';
        });

        map.on('mouseleave', 'points', function () {
            canvas.style.cursor = '';
        });

        map.on('mousedown', 'points', function (e) {
            // Prevent the default map drag behavior.
            e.preventDefault();
            startDraggingPoint(e);
        });

        map.on('click', function(e) {
          app.ports.messageReceiver.send
              ( { 'msg' : 'click'
                , 'lon' : e.lngLat.lng
                , 'lat' : e.lngLat.lat
            } );
        });
    }
};

var orangeMarker = new mapboxgl.Marker({ color: "#FFA500" });
var purpleMarker = new mapboxgl.Marker({ color: "#800080", scale: 0.8 });
var whiteMarker = new mapboxgl.Marker({ color: "#FFFFFF", scale: 0.8 });

function addOptionals(msg) {
    if (typeof(msg.orange) != 'undefined') {
        orangeMarker
            .setLngLat([msg.orange.lon, msg.orange.lat])
            .addTo(map);
    }

    if (typeof(msg.purple) === 'undefined') {
        purpleMarker.remove();
    } else {
        purpleMarker
            .setLngLat([msg.purple.lon, msg.purple.lat])
            .addTo(map);
    };

    if (typeof(msg.white) === 'undefined') {
        whiteMarker.remove();
    } else {
        whiteMarker
            .setLngLat([msg.white.lon, msg.white.lat])
            .addTo(map);
    };

//    console.log(msg.previews);
    msg.previews.forEach(addPreview);
};

function addPreview(preview) {

    //console.log(preview);

    if (map.getLayer(preview.name)) map.removeLayer(preview.name);
    if (map.getSource(preview.name)) map.removeSource(preview.name);

    map.addSource(preview.name, {
        'type': 'geojson',
        'data': preview.points
        });

    map.addLayer({
        'id': preview.name,
        'type': 'line',
        'source': preview.name,
        'layout': {
        'line-join': 'round',
        'line-cap': 'round'
        },
        'paint': {
            'line-color': preview.colour,
            'line-width': 4
        }
    });

};

function createSketchMap(msg) {
    // Make another map for route sketching.
    sketchMap = new mapboxgl.Map({
            container: 'sketchMap',
            style: 'mapbox://styles/mapbox/streets-v11',
            center: [msg.lon, msg.lat],
            zoom: msg.zoom
        });

    sketchMap.on('load', () => {
        completeSketchMapInitialisation()
    });
}

var draw;

function completeSketchMapInitialisation() {

    draw = new MapboxDraw({
        displayControlsDefault: false,

        // Select which mapbox-gl-draw control buttons to add to the map.
        controls: {
            line_string: true,
            // polygon: true,
            trash: true
        },

        // Set mapbox-gl-draw to draw by default.
        // The user does not have to click the polygon control button first.
        defaultMode: 'draw_line_string'
    });

    // Add terrain source, so we can query elevations.
    sketchMap.addSource('mapbox-dem', {
      'type': 'raster-dem',
      'url': 'mapbox://mapbox.terrain-rgb',
      'tileSize': 512,
      'maxzoom': 14
    });

    sketchMap
      .addControl(draw)
      .setTerrain({ 'source': 'mapbox-dem'})
      ;
};

function sketchMapEnable(lon, lat, zoom) {
    sketchMap
      .resize()
      ;
};

function sketchDataCapture() {
    const data = draw.getAll();

    if(typeof(data) != 'undefined' && data != null)
    {

        const points2d = data.features[0].geometry.coordinates;
        const longitudes = points2d.map( p => p[0] );
        const latitudes = points2d.map( p => p[1] );
        const elevations = points2d.map( p => sketchMap.queryTerrainElevation(p) );

        //console.log(data);

        app.ports.messageReceiver.send(
          { 'msg' : 'sketch'
          , 'longitudes' : longitudes
          , 'latitudes' : latitudes
          , 'elevations' : elevations
          }
        );
    };
};

</script>

</html>